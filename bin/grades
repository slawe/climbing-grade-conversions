#!/usr/bin/env php
<?php
declare(strict_types=1);

use Climb\Grades\Infrastructure\Bootstrap\GradeConversion;
use Climb\Grades\Domain\Service\PrimaryIndexPolicy;
use Climb\Grades\Domain\Service\TargetVariantPolicy;
use Climb\Grades\Domain\Value\GradeSystem;

require __DIR__ . '/../vendor/autoload.php';

function usage(): void
{
    $help = <<<TXT
Climbing Grade Conversions – CLI

USAGE:
  php bin/grades <gradeValue> <gradeSystem> [targetSystem] [options]

Positional args:
  <gradeValue>     e.g. "6c+" or "7a"
  <gradeSystem>    e.g. "FR", "UIAA", "YDS"
  [targetSystem]   (optional) target, e.g. "YDS", "BR"
                   - if omitted → convert to ALL other systems (range)

Options:
  --single, -1                 Return ONE result instead of a list/range
  --source-policy=lowest|middle|highest
                               How to pick source index when multiple exist
                               (default: lowest)
  --target-policy=first|middle|last
                               Which target variant to pick if the cell has multiple
                               (default: first)
  --include-source             When converting to ALL systems, include the source too
  --help, -h                   Show this help

EXAMPLES:
  php bin/grades 6c+ FR
  php bin/grades 6c+ FR YDS
  php bin/grades 7a FR BR --single --target-policy=last
  php bin/grades 6c+ FR --include-source
TXT;
    echo $help . PHP_EOL;
}

function parsePolicySource(?string $v): PrimaryIndexPolicy
{
    return match (strtolower((string)$v)) {
        '', 'lowest'  => PrimaryIndexPolicy::LOWEST,
        'middle'      => PrimaryIndexPolicy::MIDDLE,
        'highest'     => PrimaryIndexPolicy::HIGHEST,
        default       => throw new InvalidArgumentException("Unknown --source-policy: {$v}")
    };
}

function parsePolicyTarget(?string $v): TargetVariantPolicy
{
    return match (strtolower((string)$v)) {
        '', 'first'   => TargetVariantPolicy::FIRST,
        'middle'      => TargetVariantPolicy::MIDDLE,
        'last'        => TargetVariantPolicy::LAST,
        default       => throw new InvalidArgumentException("Unknown --target-policy: {$v}")
    };
}

// ---- parse argv -------------------------------------------------------------

$args = $_SERVER['argv'];
array_shift($args); // strip script name

$flags = [
    'single'         => false,
    'include_source' => false,
    'source_policy'  => 'lowest',
    'target_policy'  => 'first',
];

$positionals = [];

foreach ($args as $a) {
    if ($a === '--help' || $a === '-h') {
        usage();
        exit(0);
    }
    if ($a === '--single' || $a === '-1') {
        $flags['single'] = true;
        continue;
    }
    if ($a === '--include-source') {
        $flags['include_source'] = true;
        continue;
    }
    if (str_starts_with($a, '--source-policy=')) {
        $flags['source_policy'] = substr($a, strlen('--source-policy='));
        continue;
    }
    if (str_starts_with($a, '--target-policy=')) {
        $flags['target_policy'] = substr($a, strlen('--target-policy='));
        continue;
    }
    // positional
    $positionals[] = $a;
}

if (count($positionals) < 2) {
    usage();
    exit(1);
}

[$value, $system] = $positionals + [null, null];
$target = $positionals[2] ?? null;

try {
    $systemEnum = GradeSystem::from(strtoupper($system));
} catch (Throwable $e) {
    fwrite(STDERR, "Unknown grade system: {$system}\n");
    exit(1);
}

$sourcePolicy = parsePolicySource($flags['source_policy']);
$targetPolicy = parsePolicyTarget($flags['target_policy']);

// ---- run -------------------------------------------------------------------

try {
    $facade = GradeConversion::from($value, strtoupper($systemEnum->value));

    if ($target !== null) {
        // have a target system
        $targetEnum = GradeSystem::from(strtoupper($target));

        if ($flags['single']) {
            $one = $facade->towards($targetEnum)->single($sourcePolicy, $targetPolicy);
            if ($one === null) {
                echo "No conversion available for {$value} {$systemEnum->value} → {$targetEnum->value}\n";
                exit(0);
            }
            echo "{$value} {$systemEnum->value} -> {$one->value()} {$targetEnum->value}\n";
            exit(0);
        }

        // default: RANGE (list)
        $list = $facade->to($targetEnum); // BC behavior
        if ($list === []) {
            echo "No conversion available for {$value} {$systemEnum->value} → {$targetEnum->value}\n";
            exit(0);
        }

        echo "Conversions for {$value} {$systemEnum->value} → {$targetEnum->value}:\n";
        foreach ($list as $g) {
            echo "- {$g->value()}\n";
        }
        exit(0);
    }

    // no target system → ALL systems
    $all = $facade->toAll($flags['include_source']);

    echo "Conversions for {$value} {$systemEnum->value} (all systems):\n";
    foreach ($all as $sys => $grades) {
        $vals = array_map(static fn($g) => $g->value(), $grades);
        echo "- {$sys}: " . implode('/', $vals) . "\n";
    }
    exit(0);

} catch (Throwable $e) {
    fwrite(STDERR, "[error] {$e->getMessage()}\n");
    exit(1);
}
